# Пользовательская реализация OwnExecutorPool

## Обзор

Этот проект представляет собой пользовательскую реализацию пула потоков на Java под названием `OwnExecutorPool`. Он предлагает альтернативу стандартному Java `ExecutorService` со специфической архитектурой, где каждый рабочий поток (`worker thread`) имеет свою собственную выделенную очередь задач. Такая конструкция нацелена на эффективное управление и выполнение асинхронных задач.

## Структура Проекта

Основные компоненты этой реализации пула потоков:

-   **`OwnExecutorPool.java`**: Основной класс, реализующий интерфейс `CustomExecutor`. Он управляет коллекцией рабочих потоков и распределяет задачи между ними.
-   **`QueueWorker.java`**: Представляет рабочий поток. Каждый `QueueWorker` имеет свою собственную блокирующую очередь, из которой он извлекает и выполняет задачи. Рабочие потоки могут завершаться по таймауту (`keepAliveTime`), если остаются неактивными в течение указанного времени.
-   **`CustomExecutor.java`**: Интерфейс, расширяющий `java.util.concurrent.Executor`. Он определяет контракт для пользовательского пула потоков, включая методы для выполнения задач (`execute`, `submit`) и завершения работы пула (`shutdown`, `shutdownNow`).
-   **`Main.java`**: Простой демонстрационный класс, показывающий, как создавать и использовать `OwnExecutorPool` для выполнения серии задач.

Проект использует SLF4J для логирования с Logback в качестве бэкенд-реализации, настроенной через `pom.xml`.

## Принцип Работы

1.  **Инициализация**:
    *   `OwnExecutorPool` создается с параметрами, такими как `corePoolSize` (начальное количество потоков), `maxPoolSize` (максимальное количество потоков - в текущей версии не используется для динамического масштабирования сверх `corePoolSize`), `queueCapacity` (емкость индивидуальной очереди каждого рабочего потока), `keepAliveTime` (время простоя для рабочих потоков) и `minSpareThreads` (минимальное количество свободных потоков - также в текущей версии не используется для динамического масштабирования).
    *   При инициализации создается и запускается `corePoolSize` рабочих потоков `QueueWorker`. Каждый `QueueWorker` инициализируется со своей собственной `LinkedBlockingQueue` указанной емкости (`queueCapacity`).

2.  **Отправка Задач**:
    *   Задачи (типа `Runnable` или `Callable`) отправляются в `OwnExecutorPool` с помощью методов `execute(Runnable)` или `submit(Callable)`.
    *   `OwnExecutorPool` распределяет поступающие задачи по индивидуальным очередям `QueueWorker`'ов в циклическом порядке (round-robin). Это означает, что каждая задача добавляется в очередь следующего рабочего потока поочередно.

3.  **Выполнение Задач**:
    *   Каждый `QueueWorker` непрерывно опрашивает свою выделенную очередь на наличие задач.
    *   Если задача доступна, рабочий поток извлекает и выполняет ее.
    *   Если очередь рабочего потока остается пустой в течение времени, указанного `keepAliveTime`, этот поток `QueueWorker` завершает свою работу.

4.  **Завершение Работы**:
    *   `shutdown()`: Инициирует плавное завершение работы. Пул перестает принимать новые задачи, но уже отправленные задачи будут выполнены. Рабочие потоки завершатся после выполнения своих текущих задач и если их очереди станут пустыми (или по истечении `keepAliveTime`).
    *   `shutdownNow()`: Пытается остановить все активно выполняющиеся задачи, прекращает обработку ожидающих задач и прерывает рабочие потоки. Он устанавливает флаг в каждом рабочем потоке для прекращения обработки.

## Потенциальные Преимущества перед Стандартным `ExecutorService`

Эта пользовательская реализация `OwnExecutorPool` с ее архитектурой выделенной очереди на каждый рабочий поток может предлагать определенные преимущества или демонстрировать иные характеристики по сравнению со стандартным `java.util.concurrent.ThreadPoolExecutor` (который обычно использует одну общую очередь задач):

1.  **Снижение Конкуренции за Очередь**: Поскольку каждый рабочий поток имеет свою собственную очередь, устраняется конкуренция за блокировку одной общей очереди. Это потенциально может улучшить пропускную способность в сценариях, где доступ к очереди становится узким местом, особенно при большом количестве задач и рабочих потоков.

2.  **Локальность/Изоляция Задач (Потенциально)**: Хотя текущая реализация использует простое циклическое распределение задач, архитектура с очередями для каждого рабочего потока может быть расширена для поддержки более сложной маршрутизации задач. Например, задачи с определенными характеристиками или потребностями в ресурсах могут быть направлены конкретным рабочим потокам или группам потоков. Это не реализовано, но является структурной возможностью.

3.  **Упрощенное Управление Каждым Рабочим Потоком (Потенциально)**: Наличие отдельных очередей может упростить мониторинг или управление задачами на уровне каждого рабочего потока, хотя это явно не реализовано в текущей версии.

4.  **Отличное Поведение `keepAliveTime`**: В `OwnExecutorPool` `keepAliveTime` напрямую приводит к завершению простаивающего рабочего потока. В стандартном `ThreadPoolExecutor` `keepAliveTime` обычно применяется к потокам, количество которых превышает `corePoolSize`.

Важно отметить, что параметры `maxPoolSize` и `minSpareThreads` определены в конструкторе `OwnExecutorPool`, но в настоящее время не используются для динамической настройки количества рабочих потоков в зависимости от нагрузки. Размер пула остается фиксированным на уровне `corePoolSize` после инициализации, а рабочие потоки завершают работу только из-за бездействия на основе `keepAliveTime`.

## Пример Использования

Смотрите `Main.java` для примера создания и использования `OwnExecutorPool`:

```java
// В Main.java
OwnExecutorPool executor = new OwnExecutorPool(
        4,  // corePoolSize
        8,  // maxPoolSize (в настоящее время не используется для динамического масштабирования)
        10, // queueCapacity (для очереди каждого рабочего потока)
        5,  // keepAliveTime
        TimeUnit.SECONDS, // единица времени для keepAliveTime
        2   // minSpareThreads (в настоящее время не используется для динамического масштабирования)
);

for (int i = 0; i < 100; i++) {
    final int taskId = i;
    executor.execute(() -> {
        System.out.println("Задача #" + taskId + " начата потоком " + Thread.currentThread().getName());
        try {
            Thread.sleep(100); // Имитация работы
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("Задача #" + taskId + " завершена потоком " + Thread.currentThread().getName());
    });
}

executor.shutdown();
```